58.	Become familiar with the architecture of the project – avoid re-inventing the wheel.

59.	Avoid clipboard inheritance.  Prefer refactoring.

60.	Do not manually edit any machine-generated code.

61.	If modifying machine generated code, modify the format and style to match this coding standard.

62.	Use partial classes whenever possible to factor out the maintained portions.

63.	Avoid comments that explain the obvious.
Code should be self-explanatory.
Good code with readable variable and method names should not require comments.

64.	Document only operational assumptions, algorithm insights and so on.  
Comments describing program flow indicate the need for 'Extract Method' refactoring.

65.	Encapsulate business rules within a class:

		Thing currentThing = new Thing();

		// Correct:
		if (currentThing.IsValid)
		{
			currentThing.Save();
		}

		// Avoid:
		if (currentThing.Value > 1 && currentThing.OtherValue == 2)
		{
			currentThing.Save();
		}

66.	Declare a constants where needed; do not use magic numbers.

67.	Use the const directive only on natural constants such as the number of days of the week.

68.	Avoid using const on read-only variables. For that, use the readonly directive.

		public class MyClass
		{
			public const int DaysInWeek = 7; 
			public readonly int Number; 
			public MyClass(int someValue) 
			{
				Number = someValue;
			}
		}

69.	Do not initialize value types to their default value.

70.	Prefer an enumerated type over a Boolean for method parameters:

		// Correct:
		public State PerformOperation(State currentState)
		{…}

		// Avoid:
		public State PerformOperation(bool isReady)

71.	Avoid multiple Main() methods in a single assembly.

72.	Make only the most necessary types public, mark others as internal.

73.	Avoid friend assemblies, as they increase inter-assembly coupling.

74.	Avoid code that blindly relies on an assembly running from a particular location.  Use of a structured settings mechanism to handle this is acceptable.

75.	Minimize code in application assemblies.  Use class libraries instead to contain business logic.

76.	Avoid providing explicit values for enums unless they are bit flags or the enum is generated by a tool.

77.	Avoid using the ternary conditional operator for complex logic; simple a or b assignments are acceptable.

78.	Avoid using pre-processor directives.  Use conditional attributes to exclude method calls:

		[Conditional("MySpecialCondition")]
		public void MyMethod()
		{…}

79.	Avoid function calls in Boolean conditional statements.
Assign into local variables and check on them.

		private bool IsEverythingOK() 
		{…}

		// Avoid:
		if (IsEverythingOK()) 
		{…}

		// Correct:
		bool ok = IsEverythingOK(); 
		if (ok)
		{…}

80.	Always use zero-based arrays.

81.	With indexed collection, use zero-based indexes

82.	Do not provide public or protected member variables. Use properties instead.

83.	Use automatically implemented properties when there is no business logic or validation for the property.

84.	Avoid using the new inheritance qualifier.  
Use override instead (ensuring consistent operation for polymorphic use)

85.	Never use unsafe code, except when using interop.

86.	Avoid explicit casting. Use the as operator to defensively cast to a type.

		Dog dog = new GermanShepherd();
		GermanShepherd shepherd = dog as GermanShepherd;
		if (shepherd != null)
		{…}

87.	Always check a delegate for null before invoking it.

88.	Do not provide public event member variables. Use event accessors instead.

		public class MyPublisher
		{
			MyDelegate _someEvent;

			public event MyDelegate SomeEvent 
			{
				add
				{
					_someEvent += value;
				}
				remove
				{
					_someEvent -= value;
				}
			}
		}

32.	Avoid defining event-handling delegates. Use EventHandler<T> instead.

33.	Favor the use of interfaces.

34.	Classes and interfaces should have at least 2:1 ratio of methods to properties.

35.	Avoid data classes (with nothing but properties).  
Use the 'Move Method' refactoring.

36.	Avoid interfaces with one member.
Interfaces as just a naming container aren't good either.

37.	Strive to have three to five members per interface.

38.	Do not have more than 20 members per interface.
Twelve is probably the practical limit.

39.	Avoid events as interface members.

40.	When using abstract classes, offer an interface as well.

41.	Expose interfaces on class hierarchies.

42.	Prefer using explicit interface implementation.

43.	Never assume a type supports an interface.
Defensively query for that interface.

		SomeType obj1;
		IMyInterface obj2;

		/* Some code to initialize obj1, then: */
		obj2 = obj1 as IMyInterface;
		if (obj2 != null)
		{
			obj2.Method1();
		}
		else
		{
			// Handle error in expected interface
		}

44.	Always code to the most abstract interface or type that supports the feature required:

		private void RespondToButtonEvent(object sender, EventArgs e)
		{
			// Correct:
			IButtonControl button = sender as IButtonControl;
			if (button != null)
			{
				string argument = button.CommandArgument; // property is defined by IButtonControl
			}

			// Avoid:
			Button button = sender as Button; // Explicit reference makes refactoring more complex
			{…}
		}

45.	Use application logging and tracing.

46.	Never use goto unless in a switch statement fall-through, or to exit a nested for loop.

47.	Always have a default case in a switch statement that asserts.

		int number = SomeMethod();
		switch (number)
		{
			case 1:
				Trace.WriteLine("Case 1:"); 
				break;
			case 2:
				Trace.WriteLine("Case 2:"); 
				break;
			default:
				Debug.Assert(false); 
				break;
		}

48.	Do not use the this reference unless invoking another constructor from within a constructor.

		// Correct use of 'this':
		public class MyClass
		{
			public MyClass(string message) 
			{}
			public MyClass() : this("Hello") 
			{}
		}

49.	Do not use GC.AddMemoryPressure().

50.	Do not rely on HandleCollector.

51.	Always run code unchecked by default (for the sake of performance), but explicitly in checked mode for overflow- or underflow-prone operations:

		private int CalcPower(int number, int power)
		{
			int result = 1;
			for (int count = 1; count <= power; count++) 
			{
				checked
				{
					result *= number;
				}
			}
			return result;
		}

52.	Avoid casting to and from System.Object in code that uses generics. Use constraints or the as operator instead:

		private class SomeClass
		{}

		// Correct:
		private class MyClass<T> where T : SomeClass 
		{
			private void SomeMethod(T t) 
			{
				SomeClass obj = t;
			}
		}

		// Avoid:
		private class MyClass<T> 
		{
			private void SomeMethod(T t) 
			{
				object temp = t;
				SomeClass obj = (SomeClass)temp;
			}
		}

53.	Do not define constraints in generic interfaces. Interface-level constraints can often be replaced by strong-typing.

		public class Customer 
		{…}

		// Correct:
		public interface ICustomerList : IList<Customer> 
		{…}

		// Avoid:
		public interface IList<T> where T : Customer 
		{…}

54.	Do not define method-specific constraints in interfaces.

55.	Do not define constraints in delegates.

56.	If a class or a method offers both generic and non generic flavors, always prefer using the generics flavor.

57.	When implementing a generic interface that derives from an equivalent non-generic interface (such as IEnumerable<T>), use explicit interface implementation on all methods, and implement the non-generic methods by delegating to the generic ones:
		public class MyCollection<T> : IEnumerable<T>
		{
			IEnumerator<T> IEnumerable<T>.GetEnumerator() 
			{…}

			IEnumerator IEnumerable.GetEnumerator() 
			{
				IEnumerable<T> enumerable = this;
				return enumerable.GetEnumerator(); 
			}
		}

58.	Prefer generic methods to entire generic classes.

59.	Always throw semantically useful exceptions from public methods.

60.	Avoid parameters that control method flow; ensure each parameter is necessary for computation.
