== ASP.NET MVC
Dow Jones has made a significant investment in the ASP.NET MVC platform, customizing the platform with several extensions and a full-fledged "view component" framework.

=== High-Level Components

==== +DowJonesHttpApplication+
The base class for any Dow Jones MVC application.  This base class configures the Ninject kernel as well as executes any IBootstrapperTasks it finds in the loaded assemblies.

==== Custom Routing (+RouteAttribute+)
Though add a new routing pattern to the routing table (RouteTable.Routes) is the “standard” way to define a custom route, too many of these custom routing patterns can quickly become difficult to manage and troubleshoot.  When you want to provide a custom route to a single action, the Framework provides the RouteAttribute which can be applied to your action as follows:

.'AuthenticationController.cs'
----
    public class AuthenticationController : DowJones.Web.Mvc.Infrastructure.ControllerBase
    {
        [Route("login")]
        public ActionResult Login()
        {
            return View("Login");
        }
    }
----

In this example, the default route (using the default “{controller}/{action}/{id}” pattern) for the Login action would be “authentication/login”.  We’d like to make this action easier to access by giving it a “vanity url”, which we can apply using the RouteAttribute, specifying our vanity url (“login”).  Once this is in place, visitors can access this action by navigating to “www.mysite.com/login”.

[[ScriptAndStylesheetRegistry]]
==== +ScriptRegistry+ and +StylesheetRegistry+
These two classes (one each per request) provide a declarative way to register script and stylesheet includes.  They can (and do) implement features such as script combining, however their declarative usage abstracts all of this from developers.  This declarative nature also allows the Infrastructure team to introduce additional features without changes to additional code.

[[ViewComponentBase]]
==== +IViewComponent+ (and +ViewComponentBase+)
ViewComponentBase's role is to make component development simple and straight-forward by abstracting much of the core logic for rendering a component and its related script and/or stylesheet resources (AKA "client resources") as well as providing a standard approach for dealing with common functionality such as component options and token handling.   

At its core it offers a few important features:

* A powerful inheritance model so all components that inherit from a component implementing the ViewComponentBase class will also be provided with their ancestor's client resources.
* Client State Mapping:  extracts important information from the component's State (Model), allowing any or all of this information to be generated elsewhere and passed via an intermediary object instead of requiring access to an instance of the view component.  The mapper supports the following types of data:
	* Client Data:  the data to be serialized into JSON and rendered to the page for the component's initialization.
	* Client Event Handlers:  key-value pair mappings of client event names to the names of their respective Javascript handler functions
	* Client Properties:  the options sent to the component
	* Tokens:  placeholder values used for globalization  [Obsolete - to be removed]

The +RazorViewComponentClassGenerator+ - as the name implies - is our custom tool which converts Razor templates into classes that implement ViewComponentBase (as opposed to WebViewPage as with the standard MVC views) so that developers can specify view markup in the powerful Razor syntax, yet still realize the benefits of the ViewComponentBase class.

==== +IViewComponentState+ (and +ViewComponentState+)
Since the Canvas requirements dictated that a component be created via a model alone, the IViewComponentState interface and ViewComponentState implementations where introduced to make this task easier via "auto-mapping" of ViewComponentBases and ViewComponentStates.  This mapping is a simple convention stating that any component that implements IViewComponent<TViewComponentState> where ViewComponentBase is any class implementing IViewComponent and TViewComponentState is any class implementing IViewComponentState.
As the framework grows into more of a general-usage framework, this class becomes less important.

==== +ViewComponentFactory+
This factory serves as a helper to create instances of view components, wiring them into the framework as needed (which usually translates to registering them with the Script and Stylesheet Registries).  This class is exposed to views via the Html.DJ() helper method and provides a number of methods to render components in a view.  The most notable methods are:
* Render (object model = Html.ViewData.Model, object htmlAttributes = null)
This method is the entry point to the object -> View Component mappings.  Given any object model, the ViewComponentFactory will attempt to locate the mapping for its appropriate view component, typically the component following the ViewComponent<TData> convention.
* RenderComponent (string componentName, object model = Html.ViewData.Model, object htmlAttributes = null)
Like the Html.RenderPartial() helper, this helper method takes the name of a component and an optional model object to pass to the component.  The component name is the simple class name of the component (e.g.  +DowJones.Web.UI.HeadlineListComponent+ would simply be +HeadlineListComponent+).
* RenderComponent <TComponent>(object model = Html.ViewData.Model, object htmlAttributes = null)
The generic RenderComponent method overload.  Allows the developer to explicitly specify which component type to render instead of looking it up by name.

[[CustomRazorViews]]
=== Custom Razor Views
Developers may use the Dow Jones MVC View Component item template to create a Razor View that compiles into a class that implements ViewComponentBase.  Different flavors of this item template exist, from a very simple (Razor view only) template to the more advanced template that includes a ViewComponentState class, an empty Stylesheet file, and a Javascript file that provides a default template of our inheritance-based client-side component classes.  Any or all of these items (e.g. the stylesheet file) can be removed if they are not used in a control.

Custom Razor views currently support the following keywords in addition to most of the standard Razor keywords:

+@ClientPlugin+::  specifies the jQuery plugin name to use when initializing the component.  This implements the abstract ClientPluginName property on ViewComponentBase.  If left empty, it is null (which means the framework will not emit initialization lines for instances of this component)

+@ScriptResource+, +@StylesheetResource+, and +@FrameworkResource+:: the Razor implementation of the attributes of the same name.  Used to register Script and Stylesheet resources with their respective Registries at runtime.  These keywords take a semicolon-delimited key-value pair (in the format of [Name]=[Value]) list of the following properties:
+
	* +Name+:  Optional property to help identify the resource within the collection
	* +Url+:  the absolute URL of the resource.  When specified, this takes priority over all other properties.   Though the value of this property may be whatever you like, the Framework assumes it is an external URL.
	* +ResourceName+:  the full embedded resource name
	* +RelativeResourceName+:  a shortened version of the resource's ResourceName, assuming the path to the resource is the namespace of the current Razor view.
	* +DeclaringType+:  the type name of any type in the assembly containing ResourceName.  This is used to get the correct assembly.  If left empty, the type of the current Razor view is assumed.
	* +ResourceKind+:  a reference to a ClientResourceKind value.  Script, Stylesheet, etc.  As would be expected, the ScriptResource and StylesheetResource set the appropriate value for this property.
	* +DependencyLevel+:  a reference to a ClientResourceDependencyLevel value indicating the relative importance/priority of this resource.  E.g.  Global, MidLevel, Component, etc. - links to higher-level resources are rendered first.

[[ClientTemplate]]
+@ClientTemplate+::  a reference to the resource to be used as a client-side JavaScript template.  This resource - written using the Underscore syntax - will be compiled on the server side and dynamically injected into the component's client-side Javascript object.  This keyword accepts the following properties:
+
	* +RelativeResourceName+:  a shortened version of the resource's ResourceName, assuming the path to the resource is the namespace of the current Razor view.
	* +TemplateID+:  the name of the client-side template.  For example, if a ClientTemplate is defined on the Portal Headline List component with a TemplateID of +success+, the framework will dynamically populate the DJ.UI.PortalHeadlineList.prototype.templates.success property with the compiled client template.  Alternatively, a fully-qualified name can be provided in this field, in which case the framework will use that verbatim (e.g.  +TemplateID = MyTemplates.success+ would translate to +window[MyTemplates.success]+). 

=== Client-Side Scripting Model
Client-side component development follows the Javascript inheritance model discussed by Jon Resig in this post.  As such, we offer a few base classes which provide core framework functionality:

DJ.Component::
offers the default implementation of data-, options-, and event delegate-handling, as well as core helpers such as _debug, _publish, and _subscribe which help simplify these things by scoping them to the current instance.  Classes deriving from DJ.Component usually have some kind of data and/or state but are not necessarily visual (DOM-related) classes.

DJ.UI.Component::
extends DJ.Component and adds DOM-related functionality such as the ability to attach to a DOM element.  This functionality includes things such as painting and tokens.
Once defined, classes following the inheritance model can be exposed as jQuery plugins using the $.plugin() helper (based on the concept discussed in this post).  For example, to expose the custom class DJ.UI.MyNewComponent as a jQuery plugin named 'dj_MyNewComponent', the following call would be made:
+
	$.plugin('j_MyNewComponent', DJ.UI.MyNewComponent);
+
The custom Dow Jones MVC View Component item templates include working templates in which you can add the custom logic for your component as well as override any of the functionality derived from the base class.

[[PresentationModels]]
=== Presentation Models
The word “model” may well be one of the most widely used (and abused) words in an architect’s vocabulary.  Even when more specific definitions start to emerge (e.g. “an object or group of objects that contain business logic”), it is still difficult to determine what goes where.  What’s worse, this definition is sure to change from project-to-project, team-to-team, or even person-to-person!
The bad news is that the concept of a Presentation Model only serves to muddy these waters by adding yet another definition to the mix.  The good news, however, is that Presentation Models (often referred to as “View Models”) serve a very specific purpose: make the interaction with the views, as well as the views themselves, cleaner and more maintainable.

==== Converting Untyped ViewData to a Presentation Model
Since the ViewDataDictionary is exactly that (a dictionary), it is quite tempting to use it as such, storing values in the Controller and accessing that same data in the View via syntax such as ViewData[“MyData”].  However, this approach is risky for a number of reasons.  Most importantly, “magic strings” are a generally bad practice and the un-typed nature of the dictionary forces risky (and unsightly!) casting code in the View.  Presentation models provide a solution to these problems.
Examine a controller and view communicating data using the ViewDataDictionary approach:

.'HomeController.cs'
----
    public ActionResult Detail( )
    {
        ViewData["FirstName"] = "Frank";
        ViewData["LastName"] = "Sinatra";
        ViewData["Address.Line1"] = "123 Stardust Way";
        ViewData["Address.City"] = "Las Vegas";
        ViewData["Address.Region"] = "Nevada";

        return View("Detail");
    }
----

.'Detail.cshtml'
----
<p>
	<label for="FirstName">First Name:</label>
	<span id="FirstName">@ViewData["FirstName"]</span>
</p>

<p>
	<label for="LastName">Last Name:</label>
	<span id="LastName">@ViewData["LastName"]</span>
</p>

<p>
	<label for="Address.Line1">Street Address:</label>
	<span id="Address.Line1">@ViewData["Address.Line1"]</span>
</p>

<p>
	<label for="Address.City">City:</label>
	<span id="Address.City">@ViewData["Address.City"]</span>
</p>

<p>
	<label for="Address.Region">State/Region:</label>
	<span id="Address.Region">@ViewData["Address.Region"]</span>
</p>
----

Now, consider this same scenario with a strongly-typed presentation model:
.'Person.cs' and 'Address.cs'
----
    public class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public Address Address { get; set; }
    }


    public class Address
    {
        public string Line1 { get; set; }
        public string City { get; set; }
        public string Region { get; set; }
    }
----

.'HomeController.cs'
----

    public ActionResult Detail( )
    {
        var person = new Person()
            {
                FirstName = "Frank",
                LastName = "Sinatra",
                Address = new Address()
                            {
                                Line1 = "123 Stardust Way",
                                City = "Las Vegas",
                                Region = "Nevada",
                            }
            };

        return View("Detail", person);
    }
----

.'Detail.cshtml'
----
@model DowJones.Web.Showcase.Models.Person

<p>
	@Html.LabelFor(x => x.FirstName)
	@Html.DisplayTextFor(x => x.FirstName)
</p>

<p>
	@Html.LabelFor(x => x.LastName)
	@Html.DisplayTextFor(x => x.LastName)
</p>

<p>
	@Html.LabelFor(x => x.Address.Line1)
	@Html.DisplayTextFor(x => x.Address.Line1)
</p>

<p>
	@Html.LabelFor(x => x.Address.City)
	@Html.DisplayTextFor(x => x.Address.City)
</p>

<p>
	@Html.LabelFor(x => x.Address.Region)
	@Html.DisplayTextFor(x => x.Address.Region)
</p>
----

At first glance, it may appear to be more code to accomplish the same goal (and it can be, which means that presentation models are not necessarily the best approach for every situation!).  However, we have introduced significant benefits simply by introducing a strongly-typed class into the mix.  

For starters, we’ve done away with the “magic strings” that need to be kept in sync between controllers and views.  Secondly, we’ve opened the doors to the powerful declarative tooling of Html helpers such as Html.LabelFor and Html.DisplayTextFor (and many, many more!).  These helpers allow you to centrally control how these elements will render, allowing for easier maintenance as the project progresses.  For example, in the untyped view we had to specifically write the <label> and <span> tags, whereas in the typed view, the Html helpers render those for us.  If we decide to change these later on, updating the typed Html helpers in one place will be a snap, whereas we’d need to do a global search and replace to update the untyped instances (inevitably missing some in the process!).

==== Take it a Step Further
Though we’ve seen how converting a loosely-typed model to a strongly-typed model offers numerous benefits, we’ve only scratched the surface of how presentation model can make views cleaner and more stable!  Since we’ve gone from a collection of non-descript “things” to a cohesive object, we can shift much more logic closer to the “model” and away from the view.
Take this loosely-typed view with a good deal of logic in it:

.'Compensation.cshtml'
----
<h2>Compensation</h2>
@if((double?)ViewModel["Salary"] > 0) {
	<p>((double)ViewModel["Salary"]).ToString("C") per year</p>
} else if((double?)ViewModel["HourlyRate"] > 0) {
	<p>((double)ViewModel["HourlyRate"]).ToString("C") per hour</p>
} else {
	<p>I don't know how much you make!</p>
}
----

Some (or all) of that looks suspiciously like business logic!  For one - though it may seem straight-forward - displaying monetary amounts can be a considerably difficult and logic-intensive process that far exceeds a simple ToString(“C”). 

Now, consider this example with a Presentation Model.  For the first pass we’ll concentrate on cleaning up the flow control (if-then-else) logic:

.'Compensation.cs'
----
    public class Compensation
    {
        public double? Salary { get; set; }
        public double? HourlyRate { get; set; }

        public bool IsSalaried
        {
            get { return Salary > 0; }
        }

        public bool IsHourly
        {
            get { return HourlyRate > 0; }
        }
    }
----

.'Compensation.cshtml'
----
@model DowJones.Web.Showcase.Models.Compensation

<h2>Compensation</h2>
@if(Model.IsSalaried) {
	<p>((double)ViewModel["Salary"]).ToString("C") per year</p>
} else if(Model.IsHourly) {
	<p>((double)ViewModel["HourlyRate"]).ToString("C") per hour</p>
} else {
	<p>I don't know how much you make!</p>
}
----

This is slightly better.  We’ve eliminated the casting and magic strings in the conditional logic, as well as making it more fluent to read.  For the next pass, let’s address the aforementioned currency issues by moving the currency-to-text conversion into the model:

.'Compensation.cs'  (partial)
----
        public string SalaryDisplayValue
        {
            get { return GetDisplayValue(Salary); }
        }

        public string HourlyRateDisplayValue
        {
            get { return GetDisplayValue(HourlyRate); }
        }

        private string GetDisplayValue(double? currency)
        {
            if (currency == null) return string.Empty;

            string displayValue = currency.Value.ToString("0.00");
                
            // Insert business logic here to determine
            // the current currency, etc...)

            return displayValue;
        }
----

.'Compensation.cshtml'
----
@model DowJones.Web.Showcase.Models.Compensation

<h2>Compensation</h2>
@if(Model.IsSalaried) {
	<p>@Model.SalaryDisplayValue per year</p>
} else if(Model.IsHourly) {
	<p>@Model.HourlyRateDisplayValue per hour</p>
} else {
	<p>I don't know how much you make!</p>
}
----

Much cleaner, easier to read, and easier to maintain!  Now, when there are changes to the way compensation rates are displayed, only one class will need to change!

At this point, this view is probably good enough, however it still has a few if clauses – let’s see if we can consolidate them:

.'Compensation.cs'  (partial)
----
	public string DisplayValue
	{
		get
		{
			if (IsSalaried)
				return string.Format("{0} per year", SalaryDisplayValue);
			else if(IsHourly)
				return string.Format("{0} per hour", HourlyRateDisplayValue);
			else
				return "I don't know how much you make!";
		}
	}
----

.'Compensation.cshtml'
----
@model DowJones.Web.Showcase.Models.Compensation

<h2>Compensation</h2>
<p>@Model.DisplayValue</p>
----

Wow – we’ve eliminated the if-then-else from the view entirely!  Of course, we haven’t eliminated the logic entirely, we’ve simply moved it closer to the model where it belongs.
Hopefully these examples have shown how leveraging a strongly-typed presentation model can provide drastic improvements to the cleanliness and maintainability of many portions of your application.

==== Presentation Model vs. Business Model
As stated earlier, the term “model” is ambiguous at best.  Despite more defined goal(s), the same is true with the term “presentation model”.  The most important question is: what goes in the “presentation model” and what does not?  

The preceding examples removed business logic from the view into classes that looked suspiciously like “business models.”  That is, they resembled concepts core to the business domain, and were even named similarly to business concepts.  The distinction between “Presentation” and “Business” models is that presentation models’ primary focus is on the view/UI layer; usually wrapping or transforming a respective business model to make it more consumable in a view.

We should assume that in the preceding examples, the Person, Address, and Compensation objects were defined in our website project and map somewhat closely to similar concepts in the business layer.  The “XDisplayValue” properties on these objects are the perfect example:  the business layer is not concerned with how to format its data for display to the user, as that is a purely UI concern.  

The business layer most likely contains some of the same or similar fields (e.g. “Salary” or “HourlyRate”), and those fields are where the presentation model will be populated from.  Consider this example controller action retrieving compensation data from the business layer and mapping it to a presentation model for use in the view:

----
    public ActionResult Compensations( )
    {
        var businessData = BusinessModel.Compensation.GetAll();

        IEnumerable<PresentationModel.Compensation> salaries =
            from salary in businessData.OfType<SalaryCompensation>()
            select new PresentationModel.Compensation() { Salary = salary.YearlySalary };

        IEnumerable<PresentationModel.Compensation> hourlyRates =
            from hourlyRate in businessData.OfType<HourlyCompensation>()
            select new PresentationModel.Compensation() { HourlyRate = hourlyRate.Rate };

        var compensations = salaries.Concat(hourlyRates);

        return View("Compensations", compensations);
    }
----

As you can see, the business model actually represents the two Compensation concepts (Salary and Hourly) with two different types, each with different property names (YearlySalary and Rate).  Since our view shows a single list of Compensation types that all need to be displayed in the same way, we depend on the PresentationModel.Compensation object to merge these two concepts back together.

Though several architects in the room may have just screamed at this thought, it was what the developer deemed necessary to happen to generate a clean view in this particular scenario. Most importantly, though, neither the business model nor the controller execute any UI-related logic (e.g. how to display currencies).  The controller merely provides the Presentation Model with the data it needs (obtained from the business model) in order to render the UI correctly.

Apply presentation models judiciously, evaluating each view individually.  Ask yourself questions such as:  

* How unique is this view?  Can I easily reuse/share an existing presentation model?  
* Is my view (and the underlying business model I wish to display) simple enough that I can just use the business model and bypass a presentation model completely?

In some cases, a presentation model may not even be necessary as the business model may provide you with everything you need.  However, if you do use the business model directly and find yourself adding a lot of logic to the view to support it or wishing that it had additional properties or methods to make your work easier, it may be time to wrap that business model in a presentation model.  Also, a word of warning:  one of the benefits of using presentation models is that they shelter your UI from having to change when the model changes.  In other words, when you bind a business model directly to the UI and have to change the business model, you will also need to find all UI references to that model and change them as well.  While this is still true with the introduction of a presentation model, the presentation model is purely code (as opposed to markup) and very easily refactored with refactoring tools.
