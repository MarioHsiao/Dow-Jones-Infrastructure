[[DependencyInjection]]
== Dependency Injection
One of the widely-used and accepted principles of good software architecture is the concept of "loose coupling" wherein various parts of the larger system are not directly dependent upon each other and highly-cohesive components focus on fulfilling one need very well.  The concept of http://en.wikipedia.org/wiki/Inversion_of_control[Inversion of Control] (IoC) is one way to achieve this loose coupling while avoiding centralized points of knowledge and execution (e.g. a procedural scripting language, implicitly executing one line after the next) and preferring instead a more modular approach in which components - and their corresponding logic - are better encapsulated.  This leads to an ecosystem of decoupled and focused components, any or all of which may be interchanged without affecting the system as a whole.  Since the vast majority of effort that is invested in software happens after the initial release this decoupling makes your software much easier to change and a small up-front time investment pays huge dividends as the project grows and matures.

The Dependency Inversion Principle, otherwise known as Dependency Injection (DI), is one of the most popular implementations of the IoC concept in an object-oriented architecture.  Under this pattern components act against abstractions instead of concrete implementations and there is a definitive op-down approach and logical separation in which high-level components leverage lower-level components, yet lower-level components are not aware of higher-level components.  For example, a web site may request a file stream from the lower-level File API, and the lower-level File API satisfies the request without any knowledge of the higher-level web site API.

Proper usage of Dependency Injection often has one very indicative sign: the absence of explicit service component creation.   In the DI pattern, components are generally not responsible for creating their dependencies, instead placing this responsibility on other components in the system.  In this way, individual components can remain ignorant of the creation and implementation details of the services they depend upon, focusing instead on leveraging functionality defined by the abstraction.  For example, if the +StockQuoteAnalysisService+ requires access to data access provided by the +StockQuoteDataService+, instead of creating an instance of the +StockQuoteDataService+ itself, the +StockQuoteAnalysisService+ would simply state this dependency somewhere in its contract (e.g. a constructor parameter or property).  In this way, the logic within +StockQuoteAnalysisService+ remains focused on the task of analyzing stock quotes, leaving the creation and management of the +StockQuoteDataService+ to higher-level consumers.   See <<DependencyInjectionInAction>> for an example of this interaction using C#.

=== Dependency Injection Techniques
Since the dependency inversion principle generally precludes the ability for components to directly create instances of other components that they depend upon, they must dvertise these dependencies to the higher-level components responsible for providing them.  This can be implemented in a few ways:

Service Location::  While the techniques above are effective ways to advertise dependencies to be satisfied in a passive manner, some components may wish to take a more active approach to retrieve their dependencies by requesting them from a Service Locator object like so:
+
	var dataService = ServiceLocator.Get<IStockQuoteDataService+>();
+
Warning:  this technique is listed here for documentation purposes. It is not actually a form of dependency injection and *should be avoided at all costs*.  In other words, *do not use this approach*!

Constructor Injection::  Using this approach, dependencies are declared in the object's constructor.  In this way, the object cannot be created without fulfilling the dependency.  Due to the fact that dependencies must be fulfilled upon creation of the object, *Constructor Injection is the most favorable approach*.  Following is an example of constructor injection:
+
	public +StockQuoteAnalysisService+(IStockQuoteDataService+ dataService)

Property Injection::  Like Constructor Injection, dependencies can be advertised via object properties though which consumers of the object may assign the dependencies after an instance of the object has been created.  This approach is most suitable for situations when a dependency is "optional" (i.e. a suitable default exists), or when constructor injection cannot be used (e.g. a circular dependency exists).  An example of property injection is:
+
	public IStockQuoteDataService+ +StockQuoteDataService+ { get; set; }

Method Injection::  Method Injection describes the scenario in which a dependency is provided in the parameters of a method. Because the two previous methods easily handle the majority of situations, the Method Injection approach is rarely used, but can still be helpful at times.  Generally speaking, this approach is helpful in two scenarios:
	** 'Setter method' - this is largely synonymous to Property Injection, but instead of setting a property directly, a method (e.g. SetHostname(hostname)) is used.  This allows classes to properly encapsulate and protect their properties.  Because of the power provided by .NET's property getters and setters, this method is rarely needed.
	** 'Command/template method' - in some scenarios, a class may contain logic that executes against another component that may be different for any given execution of the method.  Since this other component may change freely while the rest of the logic remains the same, the best way to handle this is typically by passing (injecting) the other component via a method parameter.  
	+
	A classic example is that of an +XmlWriter+:  +new XElement("body").WriteTo(xmlWriter);+
	+
	In this example, we are passing in our instance of xmlWriter to the .WriteTo() method.  Thus, the higher-level components remain in full control xmlWriter, including its concrete type and implementation details such as the file path it's writing to.

=== Dependency Injection and Unit Testing
A primary benefit of loosely-coupled architecture is the ability to easily interchange components - an ability that greatly eases automated unit testing efforts.  When implementing automated unit tests, one of the most important goals is to sufficiently isolate the system you are testing, effectively controlling its environment to produce reliable and reproducible inputs and outputs.  When systems are hard-coded against concrete implementations, this is often difficult or impossible to do, but when dependency injection is applied properly, unit tests are free to exchange components with mocks or stubs, allowing complete control over the environment surrounding the target component.

=== Dependency Injection Frameworks
Though the example in <<DependencyInjectionInAction>> is a good example of leveraging Dependency Injection, it is also quite simplistic - real world dependencies are often much deeper and more complex than the simple relationship between an analysis service and a data access service.  Much more likely, both services would have quite a few more dependencies and be buried deeper in the application stack that the ConsoleRunner entry point shown.  As these relationships grow deeper and more complex, tools such as Dependency Injection Frameworks (aka Dependency Injection Containers) greatly ease the burden of managing the relationships and dependencies between the various components of a software system.  In this way, developers can declare dependencies in their code using dependency injection techniques listed above while letting a Dependency Injection Framework decipher the resulting complex object graphs and create dependency instances as needed.  

=== Object Scope and Lifetime Management
These frameworks often provide even more assistance to developers by providing additional advanced functionality such as object lifetime/scope management.  Features like these aid in the implementation of loosely-coupled components by abstracting away concepts and patterns such as Singletons.  Take the following two examples:

==== Usage of Singleton
----
public class StockQuoteAnalysisService
{
    public void AnalyzeStockQuotes()
    {
        Logger.Current.Debug("Starting to analyze stock quotes...");
		...
	}
}
----

==== Converted to Dependency Injection (with lifetime management)
----
public class StockQuoteAnalysisService
{
    private readonly ILogger _logger;

    public StockQuoteAnalysisService(ILogger logger)
    {
        _logger = logger;
    }

    public void AnalyzeStockQuotes()
    {
        _logger.Debug("Starting to analyze stock quotes...");
		...
	}
}
----

Since ILoggers are expensive to create, the initial approach relies on a Singleton Logger instance that manages its own lifetime - initializing itself once and only once.  The latter approach instead advertises the dependence upon an ILogger in its constructor, removing the tight coupling of this service to the Logger singleton.  This code may continue to avoid duplicating expensive initialization because the Dependency Injection Framework that fulfills the ILogger dependency can be configured to create only one instance of ILogger, returning the same instance every time, effectively replicating the Singleton pattern while providing an important abstraction, allowing for the ILogger implementation to be changed (e.g. from a Singleton to some other pattern) without affecting the rest of the system.

This is a powerful example of how Dependency Injection and Dependency Injection Frameworks can help and encourage better application architecture.  For a review and recommendation of the various Dependency Injection Frameworks available in the .NET arena as of the time of this writing (Oct. 2010), see Dependency Injection Frameworks Comparison.

=== Dependency Injection and ASP.NET MVC
Arguably the greatest benefit of the Model-View-Controller (MVC) pattern is its emphasis on loose coupling and separation of concerns.  Since the Dependency Injection pattern shares these same fundamental principles, the two patterns are very commonly combined together to great effect, and Microsoft's highly-extensible ASP.NET MVC framework provides excellent integration points that make these patterns very easy to implement together.

Just about every component of the ASP.NET MVC framework is interchangeable, from the way Controllers and Views are located, instantiated, and executed to the way that models are validated.  ASP.NET MVC provides several important extensibility points relevant to dependency injection:

==== Controller Factories
By default, ASP.NET MVC Controller classes must include a default constructor.  This requirement derives from the fact that the ASP.NET MVC framework does not have a dependency injection container built in, so the default Controller Factory implementation does not have the information required to fill the parameters of anything but a default constructor.  One of the most important DI integration points the ASP.NET MVC provides is the ability to provide your own implementation of IControllerFactory - an implementation with the ability to leverage a particular DI container to create and initialize Controller instances.  This is achieved with a simple call to:
   System.Web.Mvc.ControllerBuilder.Current.SetControllerFactory([Type or instance]);
Several of the popular Dependency Injection frameworks provide custom Controller Factory implementations that work with their containers.  Luckily, implementing custom Controller Factory implementations for most frameworks that do not provide implementations is a relatively trivial task.

==== Model Binders
Model Binders are a powerful way to transform parameters from a web request to object instances, encouraging an object-oriented approach to Controller Actions (i.e. working with objects as opposed to a set of loosely-associated parameters).  Since Model Binders (and the classes they create instances of) are fully capable of implementing Dependency Injection, it is important for the dependency injection framework to participate in this subsystem.  Fortunately, ASP.NET MVC makes this easy with a simple call to:
   System.Web.Mvc.ModelBinders.Binders.Add([Model Type], [Model Binder]);

==== View Engines
Just as the logic implemented in Controller Actions is very important, so too is the ability to locate and render the View needed to relay the Action's response to consumers.  Since there are a multitude of markup languages and syntax - and a View Engine implementation for each of them - ASP.NET MVC provides extensibility points to override the default View Engine (the Web Forms View Engine).  Almost by definition, Views (and the Engines that render them) should not include much logic, let alone such advance logic that would necessitate Dependency Injection to manage.  Thus, in the context of Dependency Injection the ability to inject View Engines is not very important, but is important to mention regardless, as the need for such functionality may arise.  If such a scenario occurs, the solution is:
   System.Web.Mvc.ViewEngines.Engines.Add([IViewEngine]);

=== Dependency Injection and Windows Communication Foundation
Much like ASP.NET MVC Controllers, the Windows Communication Foundation (WCF) runtime expects service classes to contain a default (parameterless) constructor and will not instantiate an instance of the service without one.  Just as ASP.NET MVC provides an extension point via custom Controller Factories, WCF also provides similar functionality in the form of custom Service Host Factories.  And - just as with ASP.NET MVC Controller Factories - some dependency injection frameworks provide custom Service Host Factory implementations to make it much easier and transparent to leverage Dependency Injection with WCF services.  When DI frameworks do not provide their own implementations, developers can take this task into their own hands and create their own relatively easily.

[[DependencyInjectionInAction]]
=== Dependency Injection in Action

.Without Dependency Injection
----
public class ConsoleRunner
{
    public static void Main(string[] args)
    {
        var analysisService = new StockQuoteAnalysisService();
        analysisService.AnalyzeStockQuotes();
    }
}

public class +StockQuoteAnalysisService+
{
    public void AnalyzeStockQuotes()
    {
        var +StockQuoteDataService+ = new StockQuoteDataService();
        var stockQuotes = StockQuoteDataService.GetStockQuotes();
        // [  Analyze stock quotes... ]
    }
}
----

.With Dependency Injection
----
public class ConsoleRunner
{
   public static void Main(string[] args)
   {
       // The high-level ConsoleRunner component is now responsible 
       // for creating and managing the instance of StockQuoteDataService
       var dataService = new StockQuoteDataService();

       // ConsoleRunner passes the StockQuoteDataService instance
       // via the object's constructor (Constructor Injection)
       var analysisService = new StockQuoteAnalysisService(dataService);
       analysisService.AnalyzeStockQuotes();
   }
}

public class StockQuoteAnalysisService
{
    private readonly IStockQuoteDataService _dataService;

    public StockQuoteAnalysisService(IStockQuoteDataService dataService)
    {
        _dataService = dataService;
    }

    public void AnalyzeStockQuotes()
    {
        // The analysis service uses the instance it was provided
        // rather than creating its own.  Thus, it can focus on
        // the work of analysis and not data retrieval.
        var stockQuotes = _dataService.GetStockQuotes();
        
        // ...

Types of Dependency Injection in action

public class StockQuoteAnalysisService
{
    private readonly IStockQuoteDataService _dataService;

    // Property injection:  consumers can provide an alternate ILogger
    public ILogger Logger
    {
        get { return _logger; }
        set { _logger = value; }
    }
    private ILogger _logger = new NullLogger();

    // Constructor injection:  consumers must supply an IStockQuoteDataService
    public StockQuoteAnalysisService(IStockQuoteDataService+ dataService)
    {
        _dataService = dataService;
    }

    // Method injection:  consumers supply their own TextWriter
    public void AnalyzeStockQuotes(TextWriter writer)
    {
        // Service Location: the method requests an instance from the 
        //                   Service Locator class
        var auxiliaryService = ServiceLocator.Resolve<IAuxiliaryService>();
    }
}
----